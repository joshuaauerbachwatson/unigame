/**
 * Copyright (c) 2021-present, Joshua Auerbach
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Foundation
import AuerbachLook

// Represents a Player.  The player is known by a name and has an "order" field and an optional
//    score field.
// The leader will have order 1.  All other players have randomly generated orders in the range
//    2...UInt32.max. The order determines the order in which players appear in the player list
//    and governs the succession of play.
// The score is always present but remains zero if unused.  The use of the score field is governed
//    by the `scoring` variable in the model.
// A Player structure is Comparable on its order field.
// It is not Codable per se but has a simple serialization / deserialization for transmission purposes.
struct Player : Equatable, Comparable {
    let name : String
    let order : UInt32
    var score : UInt32 = 0

    // Memberwise initializer not generated by compiler since I declare another initializer
    init(name: String, order: UInt32) {
        self.name = name
        self.order = order
    }
    
    // Initializer to deserialize a token in a transmitted player list.
    // Colons separate three portions:
    //   - a base64 encoded name
    //   - an order string
    //   - a score string
    // The order string and score string must represent UInt32 values and the order must be positive.
    // These constraints should be met with high probability since encoding is not under user control,
    // nor is the order field, and scores are checked before being entered into the player structure.
    init?(_ coded: String) {
        let parts = coded.split(separator: ":")
        if parts.count != 3 {
            return nil
        }
        guard let nameData = Data(base64Encoded: String(parts[0])) else { return nil }
        guard let name = String(data: nameData, encoding: .utf8) else { return nil }
        guard let order = UInt32(parts[1]), order > 0 else { return nil }
        self.init(name: name, order: order)
        guard let score = UInt32(parts[2]) else { return nil }
        self.score = score
    }
    
    // Initializer used to generate your own Player struct (once).  The mustPlayFirst argument
    // will be true for leader, false for others.
    init(_ name: String, _ mustPlayFirst: Bool) {
        Logger.log("Player \(name) created with mustPlayFirst=\(mustPlayFirst)")
        let order = mustPlayFirst ? 1 : arc4random_uniform(UInt32.max - 2) + 2
        self.init(name: name, order: order)
    }

    // Turn the player into a transmittable token
    var token : String {
        let name = Data(self.name.utf8).base64EncodedString()
        return "\(name):\(String(order)):\(String(score))"
    }
    
    // Display the player meaningfully.  Note: this display includes order but not score.
    // It is designed for messages and dialogs, not primary display in the UI.
    var display : String {
        return "\(name)(\(String(order)))"
    }

    // Compare two players to determine ordering of a player list.  This enables proper sorting of the list.
    static func < (lhs: Player, rhs: Player) -> Bool {
        return lhs.order < rhs.order
    }
}

// Encode an array of players, along with a "max players" number.  Note: by design numPlayers is
// specified separately and need not be equal to the count of the players array.
func encodePlayers(_ numPlayers: Int, _ players: [Player]) -> String {
    let tokens = players.map { $0.token }
    return "\(numPlayers) \(tokens.joined(separator: " "))"
}

// Decode an array of players (prefixed by a number of players which may differ from the count of the array)
func decodePlayers(_ coded: String) -> (Int, [Player])? {
    let tokens = coded.split(separator: " ")
    guard let numPlayers = Int(tokens[0]) else { return nil }
    var players: [Player] = []
    for token in tokens.dropFirst() {
        guard let player = Player(String(token)) else { return nil }
        players.append(player)
    }
    return (numPlayers, players)
}
